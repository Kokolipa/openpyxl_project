{"version":3,"file":"makeVariantClasses.js","sourceRoot":"../src/","sources":["makeVariantClasses.ts"],"names":[],"mappings":";;;IAMA;;;;OAIG;IACH,IAAM,YAAY,GAAG,UAAC,SAAc,EAAE,QAAa;QACjD,OAAA,OAAO,SAAS,KAAK,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS;IAAjE,CAAiE,CAAC;IAEpE,IAAM,eAAe,GAAG,UAAC,QAA8B,EAAE,KAAY,EAAE,IAAa,EAAE,MAAe;QACnG,IAAM,MAAM,GAA2B,EAAE,CAAC;QAE1C,IAAI,QAAQ,EAAE;YACZ,QAAQ,GAAG,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAEzC,KAA0B,UAAsB,EAAtB,KAAA,MAAM,CAAC,IAAI,CAAC,QAAS,CAAC,EAAtB,cAAsB,EAAtB,IAAsB,EAAE;gBAA7C,IAAM,WAAW,SAAA;gBACpB,IAAM,YAAY,GAAG,WAAW,KAAK,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,GAAG,WAAW,CAAC;gBAE9E,IAAM,IAAI,GAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,yCAAmB,CAAC,QAAS,CAAC,WAAW,CAAC,EAAE,MAAM,CAAW,CAAC,CAAC;gBAEzG,0EAA0E;gBAC1E,2DAA2D;gBAC3D,IAAI,IAAI,EAAE;oBACR,IAAI,CAAC,WAAW,GAAG,KAAG,IAAI,IAAG,KAAK,CAAC,EAAE,IAAI,EAAE,CAAE,CAAC;oBAC9C,IAAI,WAAW,KAAK,MAAM,EAAE;wBAC1B,IAAI,CAAC,WAAW,IAAI,OAAK,WAAa,CAAC;qBACxC;iBACF;aACF;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;IA4BF;;;;OAIG;IACU,QAAA,kBAAkB,GAAG,UAChC,OAA6C;QAErC,IAAA,uBAAM,EAAE,2BAAQ,EAAE,mBAAI,EAAE,uBAAM,CAAa;QAEnD,yFAAyF;QACzF,+CAA+C;QAC/C,IAAM,aAAa,GAA6B,UAAC,KAAY;;YAC3D,IAAM,aAAa,GAAG,IAAI,CAAC,CAAC,mBAAC,KAAK,0CAAE,UAAU,0CAAG,IAAI,2CAAG,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;YAE7E,OAAO;gBACL,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC;gBAC3B,eAAe,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC;gBAC9C,eAAe,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC;aACpD,CAAC;QACJ,CAAC,CAAC;QAEF,OAAO,yBAAW,CAAS,aAAoB,CAAC,CAAC;IACnD,CAAC,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { tokensToStyleObject } from './tokensToStyleObject';\nimport { Variants, Theme } from '@fluentui/theme';\nimport { IStyle } from '@uifabric/merge-styles';\nimport { makeClasses } from './makeClasses';\n\n/**\n * Calls a function with the argument, or returns the given object.\n * @param objOrFunc - Function or object.\n * @param argument - Argument to pass if a function is provided.\n */\nconst callOrReturn = (objOrFunc: any, argument: any) =>\n  typeof objOrFunc === 'function' ? objOrFunc(argument) : objOrFunc;\n\nconst processVariants = (variants: Variants | undefined, theme: Theme, name?: string, prefix?: string) => {\n  const result: Record<string, IStyle> = {};\n\n  if (variants) {\n    variants = callOrReturn(variants, theme);\n\n    for (const variantName of Object.keys(variants!)) {\n      const modifierName = variantName === 'root' ? variantName : '_' + variantName;\n\n      const rule: any = (result[modifierName] = tokensToStyleObject(variants![variantName], prefix) as IStyle);\n\n      // The display name should be tied to the unique theme object, causing the\n      // renderer to treat scoped themes as sandboxed css scopes.\n      if (name) {\n        rule.displayName = `${name}${theme.id || ''}`;\n        if (variantName !== 'root') {\n          rule.displayName += `--${variantName}`;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n * Options for makeVariantClasses.\n */\nexport type MakeVariantClassesOptions<TVariants = Variants> = {\n  /**\n   * Name of the component to use for fetching variants from the theme.\n   */\n  name?: string;\n\n  /**\n   * Prefix for css variables within the variants.\n   */\n  prefix?: string;\n\n  /**\n   * Styles for the component.\n   */\n  styles?: Record<string, IStyle> | ((theme: Theme) => Record<string, IStyle>);\n\n  /**\n   * Variants for the styles. A variant defines token values when a particular prop is present, or the\n   * variant prop matches.\n   */\n  variants?: TVariants | ((theme: Theme) => TVariants);\n};\n\n/**\n * Hook factory for creating a `use*Variants` helper. Variants represent a configuration of\n * token values mapped to modifiers on the component. A variant can also be referenced using\n * a variant string. Variants can be overridden through the theme of the component.\n */\nexport const makeVariantClasses = <TState = {}, TVariants = Variants>(\n  options: MakeVariantClassesOptions<TVariants>,\n) => {\n  const { styles, variants, name, prefix } = options;\n\n  // This function will only be called when styles have not been evaluated for this set for\n  // the particular theme/window/direction combo.\n  const styleFunction: (theme: Theme) => IStyle = (theme: Theme) => {\n    const themeVariants = name ? theme?.components?.[name]?.variants : undefined;\n\n    return [\n      callOrReturn(styles, theme),\n      processVariants(variants, theme, name, prefix),\n      processVariants(themeVariants, theme, name, prefix),\n    ];\n  };\n\n  return makeClasses<TState>(styleFunction as any);\n};\n"]}